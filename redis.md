## redis

### 1. 数据结构
#### a. sds
TODO

#### b. 链表
TODO

#### c. 字典
TODO

#### d. 跳跃表
TODO

#### e. 整数集合
TODO

#### f. 压缩列表
TODO

#### g. 对象
TODO
#### h. bitmap
bitmap是redis基于sds实现的一个扩展的数据结构，目前string支持最大的长度为512MB, 则bitmap的最大长度为2^32 = 512MB = 2^29 bytes = 2^32 bits

### 2. redis键空间
在redisDb的数据结构中，dict字段维护了所有的键值对，称为键空间

### 3. 过期时间
redisDb的数据结构中，还有个expires字典，保存了所有键的过期时间。　　　
过期时间的key-value分别是：
key : 指向键空间中，某个键对象的指针
value : long 型的毫秒精度的unix时间戳，即这个键的失效时间

#### 过期键删除策略
判断键是否过期有三种策略：
##### 1. 定时删除
在设置键过期时间时，创建定时器，让定时器在过期时间来临时，立即执行对键的删除操作。　　　
缺点：消耗CPU，影响redis的响应时间和吞吐量

##### 2. 惰性删除
每次从键空间获取键时，都检查是否过期，如果过期则删除；如果不过期，则返回该键。　　　
缺点：对内存非常不友好，造成一些长期不会被访问的内存一直无法释放

##### 3. 定期删除
每隔一段时间，程序就对数据库进行一次检查，删除过期键。　　　
难点：需要在执行时长和频率之间达到一个合理的水平。避免太频繁退化为定时删除，避免频率太低造成内存浪费

##### 4. redis的实际删除策略
使用定期删除 + 惰性删除 这2种策略搭配的方式来删除键

## 事件
redis中事件有２种，文件事件和时间事件
- 文件事件：redis服务器通过socket与客户端或其他服务器进行连接，文件事件是服务器对socket操作的抽象。
- 时间事件：一些需要在制定时间点执行的操作，时间事件是对它们的抽象

### １. 文件事件
- 文件事件处理器是使用IO多路复用程序来监听多个socket连接，并根据套接字目前执行的任务来为套接字关联不同的时间处理器
- 当被监听的套接字准备好执行连接应答()，读取()，写入()，关闭()等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器会调用之前关联好的事件处理器来处理。
下面是文件事件处理器的构成
#### 1. 套接字
即socket连接
#### 2. I/O多路复用程序
- 负责监听多个套接字，并向文件事件分排器传送那些产生事件的套接字
- 将产生事件的套接字放到队列中，有序、同步、每次一个套接字的方式向事件分派器发送套接字。
- 当上个套接字产生的事件处理完后，才会继续向事件分派器传送下一个事件
- redis使用的是select, epoll, evport, kqueue这些函数库实现的多路复用
#### 3. 文件事件分派器：
事件的类型：
- 当套接字变得可读(客户端wirte或close) 或由新的acceptable的套接字出现，就会产生AE_READABLE事件
- 当套接字变得可写(客户端read)，就会产生AE_WRITEABLE事件

#### 4. 各种事件处理器
##### 连接应答处理器
用于对客户端的应答，redis服务器初始化时，程序会将连接应答处理器与套接字的AE_READABLE事件关联   
客户端发起connect请求 -> 生成套接字 -> 产生AE_READABLE事件 -> 关联应答处理器 -> 执行应答操作

##### 命令请求处理器
负责从套接字中读取客户端发来请求的内容，服务端收到客户端发来的请求时，套接字会产生AE_READABLE事件，关联命令请求处理器   
客户端发送命令 -> 套接字产生AE_READABLE事件 -> 关联命令请求处理器 -> 读入套接字中内容

##### 命令回复处理器
负责将服务器执行命令后得到的命令回复通过套接字返回给客户端   
客户端准备好接收回复 -> 套接字产生AE_WRITEABLE事件 -> 服务端有数据ready-> 将套接字AE_WRITEABLE事件与命令回复处理器关联 -> 命令回复处理器写套接字

#### 完整的流程示例
1. 服务端运行 -> 监听套接字的AE_READABLE事件
2. 客户端发起连接 -> 套接字产生AE_READABLE事件 -> 触发应答处理器执行(创建套接字, 关联请求处理器) -> 客户端已连接，可发送命令 
3. 客户端发送命令 -> 套接字产生AE_READABLE事件 -> 命令请求处理器执行(读命令内容) ->　传给相关程序执行
4. 套接产生字AE_WRITEABLE事件 -> 关联命令回复处理器 -> 数据写入套接字 -> 解除关联

### １. 时间事件
忽略

## 服务端的redisClient对象
每个与服务端建立连接的客户端，在服务端都会由一个redisClient的对象，存在redisServer.clients字段，是一个链表，新增一个连接会尾插一个redisClient节点   
redisClient的属性：
- 套接字描述符fd : 伪客户端伪-1(AOF文件或lua脚本)，普通客户端 > -1
- 名字(name) : 默认为空
- 标志(flag) : 记录角色和状态
- 输入缓冲区(queryBuf) : 是个sds，最大１GB，超过会关闭客户端
- 命令参数(argv) : 是个字符串数组，从输入缓冲区解析出来的命令，例如: set num 1长度为３的sds数组
- 命令长度(argc) : 上面argv数组的长度
- 命令实现函数(redisCommand) : 是个数据结构，保存了命令的实现函数、命令标志、命令需要的参数、命令执行次数和总时长等
- 输出缓冲区-固定大小(buf) : 固定长度的缓冲区，用于存长度较小的回复，默认为16KB
- 输出缓冲区已用字节-固定大小(bufpos) : 记录buf已用的字节数量
- 输出缓冲区-可变大小(reply) : buf用完或回复太大无法放入buf时用，是个sds链表

## 服务器
TODO

## 集群
### 老的复制策略
复制分为同步(sync) 和 命令传播(command propagate)
#### 同步
将从服务器数据库状态更新的和主库一样，步骤如下：
1. 从服务器向主服务器发送SYNC命令
2. 主服务器执行BGSAVE命令，后台生成RDB文件，使用缓冲区记录新增写命令
3. 将生成的RDB文件发送给从服务器，从服务器读文件并更新
4. 主服务器将缓冲区中的写命令发送给从服务器，从服务器更新至最新状态

#### 命令传播
主服务器将写命令发送给从服务器

#### 缺陷
对于断线后再同步，同步RDB时会将所有数据再同步一遍，可能主从服务器中绝大多数都是一样的

### 新的复制策略
1. 初次同步和老策略一样
2. 断线后同步只同步部分

#### 同步策略
1. 偏移量: 主从都委会一个复制偏移量，主向从同步时，会在偏移量上加N，从收到后也会在偏移量加N
2. 复制积压缓冲区(默认为１MB) : 如果断线后同步时，从的偏移量之后的数据缓冲区中有，　则部分重同步；如果缓冲区中已的数据已无法满足从的同步，则全量RDB同步


## 常见问题
### 布隆过滤器
布隆过滤器原理：https://www.cnblogs.com/liyulong1982/p/6013002.html
布隆过滤器应用：[使用redis实现分布式布隆过滤器](https://blog.csdn.net/ncuzengxiebo/article/details/82813900)

